use std::{env, fs};
use std::fmt::Debug;
use std::path::Path;
use askama::Template;
use packvm::compiler::{EnumDef, SourceCode, StructDef, TypeAlias, TypeDef};

#[derive(Template)]
#[template(path = "unpack_struct.c", escape = "none")]
struct UnpackStructFnTemplate {
    fn_name: String,
    fields: Vec<Field>,
}

struct Variant {
    name: String,
    is_std: bool,
}

#[derive(Template)]
#[template(path = "unpack_enum.c", escape = "none")]
struct UnpackEnumFnTemplate {
    enum_name: String,
    variants: Vec<Variant>,
}

#[derive(Template)]
#[template(path = "unpack_alias.c", escape = "none")]
struct UnpackAliasFnTemplate {
    alias: String,
    call: FunctionCall,
}

#[derive(Clone, Copy, Debug)]
enum Modifier {
    None,
    Optional,      // flag u8 == 1 â†’ present
    Extension,     // no flag, rely on *c < buf_len
    Array,         // uleb128 length + items
}

impl PartialEq<&str> for Modifier {
    fn eq(&self, other: &&str) -> bool {
        match self {
            Modifier::None => *other == "None",
            Modifier::Optional => *other == "Optional",
            Modifier::Extension => *other == "Extension",
            Modifier::Array => *other == "Array",
        }
    }
}

impl Default for Modifier { fn default() -> Self { Modifier::None } }

#[derive(Clone, Debug, Default)]
struct FunctionCall {
    type_name: String,
    modifier: Modifier,
    args: Vec<String>,
}

#[derive(Clone, Default, Debug)]
struct Field {
    name: String,
    call: FunctionCall
}

struct FunctionDef {
    name: String,
    code: String,
}

struct AliasDef {
    alias: String,
    code: String,
}

#[derive(Template)]
#[template(path = "module.c", escape = "none")]
struct ModuleCTemplate {
    functions: Vec<FunctionDef>,
    aliases: Vec<AliasDef>,
    m_name: String,
    m_doc: String,
}

fn fn_call_from_type(
    type_name: &str,
) -> FunctionCall{
    let mut type_name = type_name.to_string();
    let modifier = if type_name.ends_with("?") {
        type_name.pop();
        Modifier::Optional
    } else if type_name.ends_with("$") {
        type_name.pop();
        Modifier::Extension
    } else if type_name.ends_with("[]") {
        type_name.pop();  type_name.pop();
        Modifier::Array
    } else {
        Modifier::None
    };
    let mut args = Vec::new();
    if type_name.starts_with("raw(") && type_name.ends_with(")") {
        let splt: Vec<String> = type_name.split("(").map(|s| s.to_string()).collect();
        let sec_splt: Vec<String> = splt[1].split(")").map(|s| s.to_string()).collect();
        let len: String = sec_splt[0].clone();

        args.push(len);
        type_name = "raw".to_string();
    }
    FunctionCall {
        type_name, modifier, args
    }
}

pub fn source_into_c<
    A: TypeAlias,
    T: TypeDef,
    E: EnumDef,
    S: StructDef<T>,
    Source: SourceCode<A, T, E, S> + Clone + Default + Debug,
>(
    name: &str,
    src: &Source
) -> String {
    let mut functions  = Vec::new();

    for struct_meta in src.structs() {
        let struct_name = struct_meta.name().to_string();
        let mut fields = Vec::new();
        for field_meta in struct_meta.fields() {
            fields.push(Field {
                name: field_meta.name().to_string(),
                call: fn_call_from_type(field_meta.type_name())
            })
        }
        let tmpl = UnpackStructFnTemplate {
            fn_name: struct_name,
            fields
        };
        functions.push(FunctionDef{
            name: struct_meta.name().to_string(),
            code: tmpl.render().expect("Failed to render template")
        });
    }

    for enum_meta in src.enums() {
        let tmpl = UnpackEnumFnTemplate{
            enum_name: enum_meta.name().to_string(),
            variants: enum_meta.variants().to_vec().iter().map(|var_name| Variant {
                name: var_name.clone(),
                is_std: src.is_std_type(var_name)
            }).collect()
        };

        functions.push(FunctionDef{
            name: enum_meta.name().to_string(),
            code: tmpl.render().expect("Failed to render unpack code")
        });
    }

    let aliases: Vec<AliasDef> = src.aliases().iter().map(|a| {
        let alias = a.new_type_name().to_string();
        let tmpl = UnpackAliasFnTemplate {
            alias: alias.clone(),
            call: fn_call_from_type(a.from_type_name())
        };
        AliasDef {
            alias,
            code: tmpl.render().expect("Failed to render template")
        }
    }).collect();

    let tmpl = ModuleCTemplate {
        functions,
        aliases,
        m_name: name.to_string(),
        m_doc: format!("Autogenerated {name} module"),
    };

    tmpl.render().expect("template render")
}

pub fn compile_py_module<
    A: TypeAlias,
    T: TypeDef,
    E: EnumDef,
    S: StructDef<T>,
    Source: SourceCode<A, T, E, S> + Clone + Default + Debug,
>(
    name: &str,
    source: &Source,
    out_dir: &Path,
    debug: bool
) -> () {
    if !out_dir.exists() {
        fs::create_dir_all(&out_dir).expect("failed to create output dir");
    }

    let src = source_into_c(name, source);

    let c_path  = out_dir.join(format!("{}.c", name));
    fs::write(&c_path, src).expect(&format!("Failed to write c file {}", c_path.display()));

    unsafe { env::set_var("HOST", "x86_64-unknown-linux-gnu"); }
    unsafe { env::set_var("TARGET", "x86_64-unknown-linux-gnu"); }
    unsafe { env::set_var("OPT_LEVEL", "3"); }
    unsafe { env::set_var("OUT_DIR", out_dir.to_str().expect("Could not unwrap out dir path into str")); }

    let mut build = cc::Build::default();
    build.file(&c_path)
        .warnings(false)
        .flag_if_supported("-std=c11")
        .include(env!("CPYTHON_INCLUDE_PATH"))
        .pic(true);

    if debug {
        build.define("__PACKVM_DEBUG", None);
    }

    let objects = build.compile_intermediates();

    // link
    let so_path = out_dir.join(format!("{}.so", name));

    let pycfg = pyo3_build_config::get();
    let libdir = pycfg.lib_dir.clone().expect("Could not find python lib dir");

    let mut link = cc::Build::new().get_compiler().to_command();
    link.arg("-shared")
        .arg("-march=native")
        .arg("-fno-semantic-interposition")
        .arg("-flto")
        .arg("-o").arg(&so_path)
        .args(&objects)
        .arg(format!("-L{}", libdir))      // <-- search path for libpython
        .arg("-lpython3.12");

    assert!(link.status().expect("link").success());
}